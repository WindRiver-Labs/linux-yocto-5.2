                 Freescale Cryptographic Services Engine (CSE3)
                ================================================

This document describes the userspace API for interacting with CSE3 security
driver. The driver is currently supported for S32V234 platforms.

                    HWRNG Interface

The driver can handle "random number generator" request coming from the Linux
HWRNG subsystem (/dev/hwrng).

Usage example:
# insert module
insmod cse3.ko
# read random bytes generated by CSE3
cat /dev/hwrng

The hwrng requests can also be tested using the rngtest tool.
E.g.: rngtest -c 100 < /dev/hwrng
If your system has more than one hardware number generator sources,
make sure to select cse3 to /sys/class/misc/hw_random/rng_current
when testing it (see Documentation/hw_random.txt).


                     IOCTL Interface

An userspace program that wants to use the CSE3 IOCTL interface has to include
include/linux/fsl/cse3_ioctl.h from the Linux source tree. This file
defines the IOCTL commands and the associated data structures.
The current driver supports the following types of requests:

1) Miyaguchi-Preneel (MP) compression

Receives a variable length buffer from userspace and returns a 128bit value
as the compression result.
This command can be issued using a CSE3_IOCTL_COMPRESS_MP ioctl request.


2) Hardware Random Number Generator

Returns a 128bit random value generated by the CSE3 Hardware.
This command can be issued using a CSE3_IOCTL_RND ioctl request.


3) Secure encrypted storage for the cryptographic keys

For extra security, the keys used for encryption/decryption and CMAC requests
can be stored in an encrypted form in secure key slots. The key update protocol
for these key slots is compliant with the one defined in "SHE. Secure Hardware
Extension" specification.

CSE3 offers 20 key slots for custom application usages, grouped in two 10-slots
banks. So, each key slot is identified by its slot id (range 0x4 to 0xD) and its
key bank. A crypto request can either use a plaintext key or one of the
encrypted keys stored in the available slots. For the second case, the key slot
id and its bank must be specified in the request.

In order to load an encrypted key in one of these slots, the ioctl command
CSE3_IOCTL_LOAD_KEY has to be called. The command expects a `ioctl_ldkey`
structure which contains: the m1, m2 and m3 message blocks defined in "SHE.
Secure Hardware Extension" specification and `kbs_key` which identifies in which
key bank the key should be loaded (the key slot id being specified in the
m1 block).

4) AES-128 Encryption/Decryption

There are several formats for the encryption/decryption requests:

a) for requests that use a plaintext key, the plaintext key has
to be set in advance using CSE3_IOCTL_SET_KEY command.

b) the same applies for requests that use AES-CBC algorithm, when the IV
also need to be set in advance using CSE3_IOCTL_SET_IV command.

c) requests that use a preloaded encrypted key (from one of the custom key
slots), have to specify the key slot id and the key bank.
Example of request using a custom key:

struct ioctl_crypt crypt;
crypt.addr_in = &buffer;  // address of the plaintext buffer in userspace
crypt.addr_out = &result; // the address where to store the results cipher text.
crypt.len = input_len/2;  // length of the input plaintext
if (hasKey) {
	crypt.key_id = keyId; // key slot id
	crypt.kbs_key = 0;    // key bank id (0 = first bank and 1 = second bank)
}
ioctl(fd, CSE3_IOCTL_ENC_ECB_WK, &crypt);

Available encryption/decryption commands:
  CSE3_IOCTL_ENC_ECB    - encrypt with plaintext key using AES-ECB
  CSE3_IOCTL_ENC_CBC    - encrypt with plaintext key using AES-CBC
  CSE3_IOCTL_DEC_ECB    - decrypt with plaintext key using AES-ECB
  CSE3_IOCTL_DEC_CBC    - decrypt with plaintext key using AES-CBC
  CSE3_IOCTL_ENC_ECB_WK - encrypt with custom key using AES-ECB
  CSE3_IOCTL_ENC_CBC_WK - encrypt with custom key using AES-CBC
  CSE3_IOCTL_DEC_ECB_WK - decrypt with custom key using AES-ECB
  CSE3_IOCTL_DEC_CBC_WK - decrypt with custom key using AES-CBC

5) CMAC Generation and Authentication

CSE3_IOCTL_GEN_MAC ioctl command can be used to generated a 128bit CMAC value
from a given input text. Similar to the encryption/decryption case,
the plaintext key also needs to be set in advance.
CSE3_IOCTL_CHECK_MAC ioctl command will generated the CMAC from the given input
text and compare it with an expected CMAC value. The command returns 0 if
the values are equal and 1 if the values differ.

6) Load plaintext key

CSE3_IOCTL_LOAD_PLKEY ioctl command will load a plaintext key in the RAM key
slot. The RAM key slot id can be further used in a crypto request that needs to
use the loaded key. As opposed to CSE3_IOCTL_LOAD_KEY command, the keys loaded
as RAM key are not stored in an encrypted form. Also, when using this key slot,
the application must make sure that no other concurrent request has overwritten
its value. Due to the non-secure nature of this command, unless really needed,
its usage is discouraged.

7) Set Key and Set IV commands

These commands (CSE3_IOCTL_SET_KEY, CSE3_IOCTL_SET_IV) don't generate an actual
hardware request. They will only attach the specified Key or IV values to the
current context, values that can be used in subsequent crypto request. The
current context is given by the file descriptor used for the ioctl commands.
So, the values set with these commands will remain active (unless overwritten)
until the file descriptor is closed.


                     Crypto API Interface

  = 1. AES-128 crypto requests =

CSE3 handles crypto requests from the socked-based Linux crypto API.
In order to export the crypto API, the kernel needs to be build
with the CONFIG_CRYPTO_USER option and CRYPTO_USER_API_SKCIPHER for
symmetric key cipher requests.

Kernel Interface

For an example on how to create/submit a kernel-level crypto request (e.g. used
in a kernel module), check the crypto tests from the linux tree: crypto/tcrypt.c.

Userspace Interface

The userspace requests are created using a socket interface. For example,
the structure below can be used to create a cipher request for "cbc(aes)"
encryption/decryption:

struct sockaddr_alg sa = {
	.salg_family = AF_ALG,
	.salg_type = "skcipher",
	.salg_name = "cbc(aes)"

tfmfd = socket(AF_ALG, SOCK_SEQPACKET, 0);
bind(tfmfd, (struct sockaddr *)&sa, sizeof(sa));

Next, the encryption key can be set as a socket option:

setsockopt(tfmfd, SOL_ALG, ALG_SET_KEY, keyString, 16);

Other options will be set in different message headers
of type "struct cmsghdr *cmsg":

- set operation (encryption/decryption)
cmsg->cmsg_level = SOL_ALG;
cmsg->cmsg_type = ALG_SET_OP;
cmsg->cmsg_len = CMSG_LEN(4);
*(__u32 *)CMSG_DATA(cmsg) = ALG_OP_ENCRYPT;

- set IV
cmsg->cmsg_level = SOL_ALG;
cmsg->cmsg_type = ALG_SET_IV;
cmsg->cmsg_len = CMSG_LEN(20);
iv = (void *)CMSG_DATA(cmsg);
iv->ivlen = 16;
memcpy(iv->iv, ivString, 16);

The message block (plain or cipher text) will be stored in a classical
"struct iovec" data structure, and the whole message will be sent over
the socket with basic socket syscalls (e.g. sendmsg).

